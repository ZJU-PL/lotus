#ifndef ANALYSIS_GVFA_VULNERABILITYCHECKERS_H
#define ANALYSIS_GVFA_VULNERABILITYCHECKERS_H

#include <map>
#include <set>
#include <string>

#include <llvm/IR/Module.h>
#include <llvm/IR/Value.h>

using namespace llvm;

// Vulnerability source/sink types
using ValueSitePairType = std::pair<const Value *, int>;
using VulnerabilitySourcesType = std::map<ValueSitePairType, int>;
using VulnerabilitySinksType = std::map<const Value *, std::set<const Value *> *>;

/**
 * Simple vulnerability checker interface
 * 
 * This interface defines the contract for vulnerability checkers that identify
 * sources and sinks for different types of vulnerabilities. Each checker
 * implements domain-specific logic for detecting potential security issues.
 */
class VulnerabilityChecker {
public:
    virtual ~VulnerabilityChecker() = default;
    
    /// Get vulnerability sources from the module
    virtual void getSources(Module *M, VulnerabilitySourcesType &Sources) = 0;
    
    /// Get vulnerability sinks from the module  
    virtual void getSinks(Module *M, VulnerabilitySinksType &Sinks) = 0;
    
    /// Check if a value transfer is valid for this vulnerability type
    virtual bool isValidTransfer(const Value *From, const Value *To) const = 0;
    
    /// Get vulnerability category
    virtual std::string getCategory() const = 0;
};

/**
 * Null pointer vulnerability checker
 * 
 * This checker identifies potential null pointer dereference vulnerabilities
 * by finding sources where null values can be introduced and sinks where
 * pointer dereferences occur.
 */
class NullPointerVulnerabilityChecker : public VulnerabilityChecker {
public:
    void getSources(Module *M, VulnerabilitySourcesType &Sources) override;
    void getSinks(Module *M, VulnerabilitySinksType &Sinks) override;
    bool isValidTransfer(const Value *From, const Value *To) const override;
    std::string getCategory() const override { return "NullPointer"; }
};

/**
 * Taint vulnerability checker
 * 
 * This checker identifies potential taint-based vulnerabilities by finding
 * sources where untrusted data can be introduced and sinks where this data
 * is used in security-sensitive operations.
 */
class TaintVulnerabilityChecker : public VulnerabilityChecker {
public:
    void getSources(Module *M, VulnerabilitySourcesType &Sources) override;
    void getSinks(Module *M, VulnerabilitySinksType &Sinks) override;
    bool isValidTransfer(const Value *From, const Value *To) const override;
    std::string getCategory() const override { return "Taint"; }
};

#endif // ANALYSIS_GVFA_VULNERABILITYCHECKERS_H
