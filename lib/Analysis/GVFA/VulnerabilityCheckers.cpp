/**
 * @file VulnerabilityCheckers.cpp
 * @brief Implementation of vulnerability checkers for Global Value Flow Analysis
 *
 * This file contains implementations of various vulnerability checkers that identify
 * sources and sinks for different types of vulnerabilities. Each checker implements
 * the VulnerabilityChecker interface and provides domain-specific logic for
 * detecting potential security issues.
 */

#include <llvm/IR/Argument.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/Debug.h>

#include "Analysis/GVFA/GlobalValueFlowAnalysis.h"
#include "Annotation/Taint/TaintConfigManager.h"

using namespace llvm;

#define DEBUG_TYPE "dyck-gvfa"

//===----------------------------------------------------------------------===//
// Vulnerability Checker Implementations
//===----------------------------------------------------------------------===//

/**
 * Helper function to iterate through all instructions in a module.
 *
 * This template function provides a convenient way to apply a function
 * to every instruction in a module, abstracting away the nested loop structure.
 *
 * @tparam Func The type of function to apply to each instruction
 * @param M The LLVM module to iterate through
 * @param func The function to apply to each instruction
 */
template<typename Func>
void forEachInstruction(Module *M, Func func) {
    for (auto &F : *M) {
        for (auto &BB : F) {
            for (auto &I : BB) {
                func(&I);
            }
        }
    }
}

/**
 * Gets null pointer vulnerability sources from the module.
 *
 * This function identifies potential sources of null pointer vulnerabilities,
 * including null constants and failed allocation functions.
 *
 * @param M The LLVM module to analyze
 * @param Sources The map to populate with vulnerability sources
 */
void NullPointerVulnerabilityChecker::getSources(Module *M, VulnerabilitySourcesType &Sources) {
    // Find null pointer sources (e.g., null constants, failed allocations)
    forEachInstruction(M, [&Sources](const Instruction *I) {
        // Null constants
        if (auto *CI = dyn_cast<ConstantPointerNull>(I)) {
            Sources[{CI, 1}] = 1;
        }
        // Failed malloc/calloc
        else if (auto *Call = dyn_cast<CallInst>(I)) {
            if (auto *CalledF = Call->getCalledFunction()) {
                StringRef Name = CalledF->getName();
                if (Name == "malloc" || Name == "calloc") {
                    Sources[{Call, 1}] = 1;
                }
            }
        }
    });
}

/**
 * Gets null pointer vulnerability sinks from the module.
 *
 * This function identifies potential sinks where null pointer dereferences
 * could occur, such as load/store instructions and array accesses.
 *
 * @param M The LLVM module to analyze
 * @param Sinks The map to populate with vulnerability sinks
 */
void NullPointerVulnerabilityChecker::getSinks(Module *M, VulnerabilitySinksType &Sinks) {
    // Find null pointer sinks (e.g., dereferences, array accesses)
    forEachInstruction(M, [&Sinks](const Instruction *I) {
        const Value *PtrOp = nullptr;
        if (auto *LI = dyn_cast<LoadInst>(I)) {
            PtrOp = LI->getPointerOperand();
        } else if (auto *SI = dyn_cast<StoreInst>(I)) {
            PtrOp = SI->getPointerOperand();
        } else if (auto *GEP = dyn_cast<GetElementPtrInst>(I)) {
            PtrOp = GEP->getPointerOperand();
        }
        
        if (PtrOp) {
            Sinks[PtrOp] = new std::set<const Value *>();
            Sinks[PtrOp]->insert(I);
        }
    });
}

/**
 * Checks if a value transfer is valid for null pointer analysis.
 *
 * This function determines whether data flow is allowed between two values
 * in the context of null pointer vulnerability detection. It blocks flow
 * through null check and assertion functions.
 *
 * @param From The source value (unused in this implementation)
 * @param To The target value to check
 * @return true if the transfer is valid, false otherwise
 */
bool NullPointerVulnerabilityChecker::isValidTransfer(const Value * /*From*/, const Value *To) const {
    // Allow flow through most instructions except sanitizers
    if (auto *CI = dyn_cast<CallInst>(To)) {
        if (auto *F = CI->getCalledFunction()) {
            StringRef Name = F->getName();
            // Block flow through null check functions
            return !Name.contains("check") && !Name.contains("assert");
        }
    }
    return true;
}

/**
 * Gets taint vulnerability sources from the module.
 *
 * This function identifies sources of potentially tainted data, such as
 * user input functions, network I/O, and file operations.
 *
 * @param M The LLVM module to analyze
 * @param Sources The map to populate with taint sources
 */
void TaintVulnerabilityChecker::getSources(Module *M, VulnerabilitySourcesType &Sources) {
    // Find taint sources (e.g., user input functions)
    forEachInstruction(M, [&Sources](const Instruction *I) {
        if (auto *Call = dyn_cast<CallInst>(I)) {
            if (auto *CalledF = Call->getCalledFunction()) {
                if (taint_config::is_source(CalledF->getName().str())) {
                    Sources[{Call, 1}] = 1;
                }
            }
        }
    });
}

/**
 * Gets taint vulnerability sinks from the module.
 *
 * This function identifies sinks where tainted data could cause security
 * issues, such as dangerous system calls, command execution, and
 * database operations.
 *
 * @param M The LLVM module to analyze
 * @param Sinks The map to populate with taint sinks
 */
void TaintVulnerabilityChecker::getSinks(Module *M, VulnerabilitySinksType &Sinks) {
    // Find taint sinks (e.g., dangerous functions)
    forEachInstruction(M, [&Sinks](const Instruction *I) {
        if (auto *Call = dyn_cast<CallInst>(I)) {
            if (auto *CalledF = Call->getCalledFunction()) {
                if (taint_config::is_sink(CalledF->getName().str())) {
                    for (unsigned i = 0; i < Call->arg_size(); ++i) {
                        auto *Arg = Call->getArgOperand(i);
                        Sinks[Arg] = new std::set<const Value *>();
                        Sinks[Arg]->insert(Call);
                    }
                }
            }
        }
    });
}

/**
 * Checks if a value transfer is valid for taint analysis.
 *
 * This function determines whether data flow is allowed between two values
 * in the context of taint vulnerability detection. It blocks flow through
 * sanitizer functions that clean or validate the data.
 *
 * @param From The source value (unused in this implementation)
 * @param To The target value to check
 * @return true if the transfer is valid, false otherwise
 */
bool TaintVulnerabilityChecker::isValidTransfer(const Value * /*From*/, const Value *To) const {
    // Block flow through sanitizer functions
    if (auto *CI = dyn_cast<CallInst>(To)) {
        if (auto *F = CI->getCalledFunction()) {
            // Note: Sanitizer functions are not yet supported in the unified config
            // For now, we'll keep a minimal hardcoded list
            static const std::unordered_set<std::string> sanitizers = {
                "strlen", "strnlen", "strncpy", "strncat", "snprintf"
            };
            return !sanitizers.count(F->getName().str());
        }
    }
    return true;
}
